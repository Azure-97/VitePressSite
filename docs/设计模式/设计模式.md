

[UML](2%20UML.md) 小知识


## 7个原则
1. 单一职责原则: 一个类负责一项职责。

2. 里氏替换原则: 继承与派生的规则。

3. 依赖倒置原则: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。

4. 接口隔离原则: 建立单一接口，尽量细化接口，接口中的方法尽量少。

5. 迪米特法则: 低耦合，高内聚。

6. 开闭原则: 一个软件实体如类、模块和函数应该**开放扩展**，**关闭修改**。

7. 组合/聚合复用原则: **尽量使用组合**和聚合少使用继承的关系来达到复用的原则。


## 创建型模式

对象实例化的模式，创建型模式用于解耦对象的实例化过程。

### 单例模式

某个类只能有一个实例，提供一个全局的访问点。

#### 6 种实现方式

##### 懒汉式-线程不安全

```java
public class Singleton {
    private static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```

##### 懒汉式-线程安全

```java
public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
```

##### 饿汉式

```java
private static Singleton uniqueInstance = new Singleton();
```

##### 双重校验锁

```java
public class Singleton {
    private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

##### 静态内部类实现

```java
public class Singleton {
    private Singleton() {
    }
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

> 延迟初始化：SingletonHolder 是一个静态内部类，这意味着它不会在 Singleton 类加载时立即加载。只有当 Singleton.getUniqueInstance() 被调用并且需要访问 SingletonHolder.INSTANCE 时，SingletonHolder 类才会被加载。
> 类加载机制：在 Java 中，类的加载是线程安全的。当多个线程同时尝试加载同一个类时，JVM 会确保只有一个线程能成功加载。
> 静态变量初始化：SingletonHolder.INSTANCE 是一个静态最终变量（static final），在类加载过程中，JVM 会确保它的初始化是原子性的，不会被其他线程干扰。这意味着即使在并发环境中，多个线程也不会同时创建 Singleton 实例。

##### 枚举实现

```java
public enum Singleton {
    uniqueInstance;
}
```

tips:一般情况下，不建议使用懒汉方式，建议使用饿汉式。只有在要明确实现 lazy loading 效果时，才会使用静态内部类。如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。

### 简单工厂

一个工厂类根据传入的**参量**决定创建出那一种产品类的实例。

#### 模式组成

![](attachments/Pasted%20image%2020240516152700.png)

#### UML 类图

![](attachments/Pasted%20image%2020240516145120.png)

#### 使用步骤

- 创建**抽象产品类** & 定义具体产品的公共接口；
- 创建**具体产品类**（继承抽象产品类） & 定义生产的具体产品；
- 创建**工厂类**，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；
- 外界通过调用工厂类的静态方法，**传入不同参数**从而创建不同**具体产品类的实例**

#### demo

接口

```java
public interface Product {
}
```

接口实现产品

```java
public class ConcreteProduct implements Product {
}
```

接口实现产品 1

```java
public class ConcreteProduct1 implements Product {
}
```

接口实现产品 2

```java
public class ConcreteProduct2 implements Product {
}
```

简单工厂

```java
public class SimpleFactory {
    public Product createProduct(int type) {
        if (type == 1) {
            return new ConcreteProduct1();
        } else if (type == 2) {
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}
```

客户端调用

```java
public class Client {
    public static void main(String[] args) {
		//根据参数生产产品
        SimpleFactory simpleFactory = new SimpleFactory();
        //传人参数1 》 生产产品1
        Product product = simpleFactory.createProduct(1);
    }
}
```

### 工厂方法

定义一个创建对象的接口，让子类决定实例化那个类。

#### 模式组成

![](attachments/Pasted%20image%2020240516152545.png)

#### UML

![](attachments/Pasted%20image%2020240516145827.png)

#### 使用步骤

步骤 1：创建**抽象工厂类**，定义具体工厂的公共接口；  
步骤 2：创建**抽象产品类** ，定义具体产品的公共接口；  
步骤 3：创建**具体产品类**（继承抽象产品类） & 定义生产的具体产品；  
步骤 4：创建**具体工厂类**（继承抽象工厂类），定义创建对应具体产品实例的方法；  
步骤 5：**外界通过调用具体工厂类的方法，从而创建不同**具体产品类的实例

#### demo

步骤 1：创建**抽象工厂类**，定义具体工厂的公共接口

```java
abstract class Factory{
    public abstract Product Manufacture();
}
```

步骤 2：创建**抽象产品类** ，定义具体产品的公共接口；

```csharp
abstract class Product{
    public abstract void Show();
}
```

步骤 3： 创建**具体产品类**（继承抽象产品类）， 定义生产的具体产品；

```java
//具体产品A类
class  ProductA extends  Product{
    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}

//具体产品B类
class  ProductB extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品B");
    }
}
```

步骤 4：创建**具体工厂类**（继承抽象工厂类），定义创建对应具体产品实例的方法；

```java
//工厂A类 - 生产A类产品
class  FactoryA extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductA();
    }
}

//工厂B类 - 生产B类产品
class  FactoryB extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductB();
    }
}
```

步骤 5：外界通过调用具体工厂类的方法，从而创建不同\*\*具体产品类的实例

```java
//生产工作流程
public class FactoryPattern {
    public static void main(String[] args){
        //客户要产品A  一个类生产一种产品
        FactoryA mFactoryA = new FactoryA();
        mFactoryA.Manufacture().Show();

        //客户要产品B   一个类生产一种产品
        FactoryB mFactoryB = new FactoryB();
        mFactoryB.Manufacture().Show();
    }
}
```

### 抽象工厂

创建相关或依赖对象的**家族**，而无需明确指定具体类。

#### 模式组成

![](attachments/Pasted%20image%2020240516154206.png)

#### UML

![](attachments/Pasted%20image%2020240516154118.png)

#### demo

抽象产品

```java
public class AbstractProductA {
}
public class AbstractProductB {
}
```

实现产品家族

```java
public class ProductA1 extends AbstractProductA {
}
public class ProductA2 extends AbstractProductA {
}
public class ProductB1 extends AbstractProductB {
}
public class ProductB2 extends AbstractProductB {
}
```

抽象工厂

```java
public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();
}
```

实现工厂家族

```java
public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA1();
    }
    AbstractProductB createProductB() {
        return new ProductB1();
    }
}
public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA2();
    }
    AbstractProductB createProductB() {
        return new ProductB2();
    }
}
```

调用

```java
public class Client {
    public static void main(String[] args) {
	    //一个工厂生产不同的产品
        AbstractFactory abstractFactory = new ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
    }
}
```

### 建造者模式

封装一个复杂对象的构建过程，并可以按步骤构造。

#### UML

![](attachments/Pasted%20image%2020240516163046.png)

#### demo

步骤 1：定义组装的过程（Builder）：组装电脑的过程

```java
public abstract class Builder {  
	//第一步：装CPU  
	//声明为抽象方法，具体由子类实现  
	public abstract void BuildCPU();  
	//第二步：装主板  
	//声明为抽象方法，具体由子类实现  
	public abstract void BuildMainboard();  
	  
	//第三步：装硬盘  
	//声明为抽象方法，具体由子类实现  
	public abstract void BuildHD();  
	  
	//返回产品的方法：获得组装好的电脑  
	public abstract Computer GetComputer();  
}
```

步骤 2： 电脑城老板委派任务给装机人员（Director）

```java
public class Director{
    //指挥装机人员组装电脑
    public void Construct(Builder builder){
        builder. BuildCPU();
        builder.BuildMainboard();
        builder. BuildHD();
    }
}
```

步骤 3： 创建具体的建造者（ConcreteBuilder）:装机人员

```java
//装机人员1
  public class ConcreteBuilder extend  Builder{
    //创建产品实例
    Computer computer = new Computer();

    //组装产品
    @Override
    public void  BuildCPU(){
       computer.Add("组装CPU")
    }

    @Override
    public void  BuildMainboard（）{
       computer.Add("组装主板")
    }

    @Override
    public void  BuildHD（）{
      computer.Add("组装主板")
    }
    //返回组装成功的电脑
     @Override
      public  Computer GetComputer（）{
      return computer
    }
}

```

步骤 4： 定义具体产品类（Product）：电脑

```csharp
public class Computer{

    //电脑组件的集合
    private List<String> parts = new ArrayList<String>();

    //用于将组件组装到电脑里
    public void Add(String part){
        parts.add(part);
    }

    public void Show(){
          for (int i = 0;i<parts.size();i++){
             System.out.println(“组件”+parts.get(i)+“装好了”);
          }
          System.out.println(“电脑组装完成，请验收”);

    }

}
```

步骤 5：客户端调用-小成到电脑城找老板买电脑

```java

public class BuilderPattern{
  public static void main(String[] args){
	
    //逛了很久终于发现一家合适的电脑店
    //找到该店的老板和装机人员
	Director director = new Director();
	Builder builder = new ConcreteBuilder();

	//沟通需求后，老板叫装机人员去装电脑
	director.Construct(builder);
	
	//装完后，组装人员搬来组装好的电脑
	Computer computer = builder.GetComputer();
	//组装人员展示电脑给小成看
	computer.Show()；

    }

}

```

结果输出

```undefined
组件CUP装好了
组件主板装好了
组件硬盘装好了
电脑组装完成，请验收
```



### 原型模式

通过复制现有的实例来创建新的实例。

#### Demo 

克隆接口
```java
Public abstract class Prototype {
    Abstract Prototype myClone ();
}
```
克隆接口实现
```java
Public class ConcretePrototype extends Prototype {
    Private String filed;
    Public ConcretePrototype (String filed) {
        This. Filed = filed;
    }
    @Override
    Prototype myClone () {
        Return new ConcretePrototype (filed);
    }
    @Override
    Public String toString () {
        Return filed;
    }
}
```
调用
```java
Public class Client {
    Public static void main (String[] args) {
        Prototype prototype = new ConcretePrototype ("abc");
        Prototype clone = prototype.MyClone ();
        System.Out.Println (clone.ToString ());
    }
}
```


## 结构型模式
把类或对象结合在一起形成一个更大的结构。
### 适配器模式
把适配的类的API转换成为目标类的API。
#### UML
![](attachments/Pasted%20image%2020240516172146.png)
Demo
>鸭子(Duck)和火鸡(Turkey)拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。
>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！

Duck 类
```java
public interface Duck {
    void quack();
}
```
Turkey 类
```java
public interface Turkey {
    void gobble();
}
```
Turkey 实现类
```java
public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println("gobble!");
    }
}
```
Turkey 适配器类
```java
public class TurkeyAdapter implements Duck {
    Turkey turkey;
    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }
    @Override
    public void quack() {
        turkey.gobble();
    }
}
```
客户端类
```java
public class Client {
    public static void main(String[] args) {
        Turkey turkey = new WildTurkey();//Turkey类
        Duck duck = new TurkeyAdapter(turkey);//Turkey适配器类
        duck.quack();
    }
}
```

### 组合模式

将对象组合成树形结构以表示“”部分-整体“”的层次结构。

> 大部分国家的军队都采用层次结构管理。每支部队包括几个师，师由旅构成，旅由团构成，团可以继续划分为排。最后，每个排由一小队实实在在的士兵组成。军事命令由最高层下达，通过每个层级传递，直到每位士兵都知道自己应该服从的命令。
#### UML
![](attachments/Pasted%20image%2020240516234340.png)

#### 核心角色 ：

- **组件（Component）:**
    - 定义了组合中所有对象的通用接口，可以是抽象类或接口。它声明了用于访问和管理子组件的方法，包括添加、删除、获取子组件等。
- **叶子节点（Leaf）:**
    - 表示组合中的叶子节点对象，叶子节点没有子节点。它实现了组件接口的方法，但通常不包含子组件。
- **复合节点（Composite）:**
    - 表示组合中的复合对象，复合节点可以包含子节点，可以是叶子节点，也可以是其他复合节点。它实现了组件接口的方法，包括管理子组件的方法。
- **客户端（Client）:**
    - 通过组件接口与组合结构进行交互，客户端不需要区分叶子节点和复合节点，可以一致地对待整体和部分。

#### Demo
抽象组件类
```java
public abstract class Component {
    protected String name;
    public Component(String name) {
        this.name = name;
    }
    public void print() {
        print(0);
    }
    abstract void print(int level);
    abstract public void add(Component component);
    abstract public void remove(Component component);
}
```
复合类：
```java
public class Composite extends Component {
    private List<Component> child;
    public Composite(String name) {
        super(name);
        child = new ArrayList<>();
    }
    @Override
    void print(int level) {
        for (int i = 0; i < level; i++) {
            System.out.print("--");
        }
        System.out.println("Composite:" + name);
        for (Component component : child) {
            component.print(level + 1);
        }
    }
    @Override
    public void add(Component component) {
        child.add(component);
    }
    @Override
    public void remove(Component component) {
        child.remove(component);
    }
}
```
叶子节点类
```java
public class Leaf extends Component {
    public Leaf(String name) {
        super(name);
    }
    @Override
    void print(int level) {
        for (int i = 0; i < level; i++) {
            System.out.print("--");
        }
        System.out.println("left:" + name);
    }
    @Override
    public void add(Component component) {
        throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点
    }
    @Override
    public void remove(Component component) {
        throw new UnsupportedOperationException();
    }
}
```
客户端类
```java
public class Client {
     public static void main(String[] args) {
         Composite root = new Composite("root");//复合类
         Component node1 = new Leaf("1");//组件类--叶子节点1
         Component node2 = new Composite("2");//组件类--叶子节点2
         Component node3 = new Leaf("3");//组件类--叶子节点3
         root.add(node1);
         root.add(node2);
         root.add(node3);
         Component node21 = new Leaf("21");//组件类--叶子节点21
         Component node22 = new Composite("22");//组件类--叶子节点22
         node2.add(node21);
         node2.add(node22);
         Component node221 = new Leaf("221");//组件类--叶子节点221
         node22.add(node221);
         root.print();
     }
 }
```
效果：
```java
Composite:root
--left:1
--Composite:2
----left:21
----Composite:22
------left:221
--left:3
```

### 装饰模式

允许向一个现有的对象添加新的功能，同时又不改变其结构
#### UML
![](attachments/Pasted%20image%2020240517095539.png)



#### **核心角色**
- 抽象组件（Component）：定义了原始对象和装饰器对象的公共接口或抽象类，可以是具体组件类的父类或接口。
- 具体组件（Concrete Component）：是被装饰的原始对象，它定义了需要添加新功能的对象。
- 抽象装饰器（Decorator）：继承自抽象组件，它包含了一个抽象组件对象，并定义了与抽象组件相同的接口，同时可以通过组合方式持有其他装饰器对象。
- 具体装饰器（Concrete Decorator）：实现了抽象装饰器的接口，负责向抽象组件添加新的功能。具体装饰器通常会在调用原始对象的方法之前或之后执行自己的操作。
#### Demo
抽象组件
```java
public interface Shape {
   void draw();
}
```

具体组件
```java
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Shape: Rectangle");
   }
}

public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Shape: Circle");
   }
}
```
抽象装饰器
```java
public abstract class ShapeDecorator implements Shape {
   protected Shape decoratedShape;
 
   public ShapeDecorator(Shape decoratedShape){
      this.decoratedShape = decoratedShape;
   }
 
   public void draw(){
      decoratedShape.draw();
   }  
}
```
具体装饰器
```java
public class RedShapeDecorator extends ShapeDecorator {
 
   public RedShapeDecorator(Shape decoratedShape) {
      super(decoratedShape);     
   }
 
   @Override
   public void draw() {
      decoratedShape.draw();         
      setRedBorder(decoratedShape);
   }
 
   private void setRedBorder(Shape decoratedShape){
      System.out.println("Border Color: Red");
   }
}
```

```java
public class DecoratorPatternDemo {
   public static void main(String[] args) {
 
      Shape circle = new Circle();
      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
      //Shape redCircle = new RedShapeDecorator(new Circle());
      //Shape redRectangle = new RedShapeDecorator(new Rectangle());
      System.out.println("Circle with normal border");
      circle.draw();
 
      System.out.println("\nCircle of red border");
      redCircle.draw();
 
      System.out.println("\nRectangle of red border");
      redRectangle.draw();
   }
}
```
输出
```java
Circle with normal border
Shape: Circle

Circle of red border
Shape: Circle
Border Color: Red

Rectangle of red border
Shape: Rectangle
Border Color: Red
```
### 代理模式

为其他对象提供一个代理以便控制这个对象的访问。
#### UML
![](attachments/Pasted%20image%2020240517101755.png)
#### 核心角色
- **抽象主题（Subject）:**
    - 定义了真实主题和代理主题的共同接口，这样在任何使用真实主题的地方都可以使用代理主题。
- **真实主题（Real Subject）:**
    - 实现了抽象主题接口，是代理对象所代表的真实对象。客户端直接访问真实主题，但在某些情况下，可以通过代理主题来间接访问。
- **代理（Proxy）:**
    - 实现了抽象主题接口，并持有对真实主题的引用。代理主题通常在真实主题的基础上提供一些额外的功能，例如延迟加载、权限控制、日志记录等。
- **客户端（Client）:**
    - 使用抽象主题接口来操作真实主题或代理主题，不需要知道具体是哪一个实现类。



#### 静态代理 demo
抽象主题类
```java
public interface Subject {  
    public void buyMac();
}
```
真实主题类
```java
  public class RealSubject implement Subject{
    @Override
    public void buyMac() {  
        System.out.println(”买一台Mac“);  
    }  
}
```
代理类
```java
public class Proxy  implements Subject{
  
    @Override
    public void buyMac{
      
      //引用并创建真实对象实例，即”我“
      RealSubject realSubject = new RealSubject()；

      //调用真实对象的方法，进行代理购买Mac
      realSubject.buyMac（）；
      //代理对象额外做的操作
      this.WrapMac()；
    }

     public void WrapMac(){
      System.out.println(”用盒子包装好Mac“);  
    }
}
```
客户端
```java
public class ProxyPattern {

    public static void main(String[] args){

    Subject proxy = new Proxy()；
    proxy.buyMac()；
    }
        
}
```

```text
买一台Mac
用盒子包装好Mac
```
#### 动态代理 demo
代理模式中的**静态代理模式**存在一些特点：
- 1个静态代理 只服务1种类型的目标对象
- 若要服务多类型的目标对象，则需要为每种目标对象都实现一个静态代理对象
区别
![](attachments/Pasted%20image%2020240517113638.png)


#### 与其他模式的关系
- [适配器模式](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口， [代理模式](https://refactoringguru.cn/design-patterns/proxy)能为对象提供相同的接口， [装饰模式](https://refactoringguru.cn/design-patterns/decorator)则能为对象提供加强的接口。

- [外观模式](https://refactoringguru.cn/design-patterns/facade)与[代理](https://refactoringguru.cn/design-patterns/proxy)的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 _代理_与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与_外观_不同。

- [装饰](https://refactoringguru.cn/design-patterns/decorator)和[代理](https://refactoringguru.cn/design-patterns/proxy)有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于_代理_通常自行管理其服务对象的生命周期， 而_装饰_的生成则总是由客户端进行控制。

### 亨元模式

通过共享技术来有效的支持大量细粒度的对象。
主要用于减少创建对象的数量，以减少内存占用和提高性能。
#### UML
![](attachments/Pasted%20image%2020240517114244.png)

#### 核心角色
- **享元工厂（Flyweight Factory）:**
    - 负责创建和管理享元对象，通常包含一个池（缓存）用于存储和复用已经创建的享元对象。
- **抽象享元（Flyweight）:**
    - 定义了具体享元和非共享享元的接口，通常包含了设置外部状态的方法。
- **具体享元（Concrete Flyweight）:**
    - 实现了抽象享元接口，包含了内部状态和外部状态。内部状态是可以被共享的，而外部状态则由客户端传递。
- **客户端（Client）:**
    - 使用享元工厂获取享元对象，并通过设置外部状态来操作享元对象。客户端通常不需要关心享元对象的具体实现。

#### Demo
**抽象享元（Flyweight）**
```java
public interface Flyweight {
    void doOperation(String extrinsicState);
}
```
**具体享元（Concrete Flyweight）**
```java
public class ConcreteFlyweight implements Flyweight {

    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void doOperation(String extrinsicState) {
        System.out.println("Object address: " + System.identityHashCode(this));
        System.out.println("IntrinsicState: " + intrinsicState);
        System.out.println("ExtrinsicState: " + extrinsicState);
    }
}
```
**享元工厂（Flyweight Factory）**
```java
public class FlyweightFactory {

    private HashMap<String, Flyweight> flyweights = new HashMap<>();

    Flyweight getFlyweight(String intrinsicState) {
        if (!flyweights.containsKey(intrinsicState)) {
            Flyweight flyweight = new ConcreteFlyweight(intrinsicState);
            flyweights.put(intrinsicState, flyweight);
        }
        return flyweights.get(intrinsicState);
    }
}
```
**客户端（Client）**
```java
public class Client {
    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight flyweight1 = factory.getFlyweight("aa");
        Flyweight flyweight2 = factory.getFlyweight("aa");
        flyweight1.doOperation("x");
        flyweight2.doOperation("y");
    }
}

```
结果：
```text
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: x

Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: y
```
### 外观模式
对外提供一个统一的方法，来访问子系统中的一群接口。
#### UML
![](attachments/Pasted%20image%2020240517135342.png)
#### 核心角色
- **外观（Facade）:**
    - 提供一个简化的接口，封装了系统的复杂性。外观模式的客户端通过与外观对象交互，而无需直接与系统的各个组件打交道。
- **子系统（Subsystem）:**
    - 由多个相互关联的类组成，负责系统的具体功能。外观对象通过调用这些子系统来完成客户端的请求。
- **客户端（Client）:**
    - 使用外观对象来与系统交互，而不需要了解系统内部的具体实现。

#### Demo
形状接口
```java
public interface Shape {
   void draw();
}
```
实现一系列形状接口
```java
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Rectangle::draw()");
   }
}

public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Square::draw()");
   }
}

public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Circle::draw()");
   }
}

```
外观类
```java
public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;
 
   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }
 
   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
```
客户端
```java
public class FacadePatternDemo {
   public static void main(String[] args) {
      ShapeMaker shapeMaker = new ShapeMaker();
 
      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();      
   }
}
```
结果
```text
Circle::draw()
Rectangle::draw()
Square::draw()
```

### 桥接模式
将抽象部分和它的实现部分分离，使它们都可以独立的变化。
#### UML
![](attachments/Pasted%20image%2020240517155535.png)
![](attachments/Pasted%20image%2020240517142139.png)
#### 核心角色
- 抽象（Abstraction）：定义抽象接口，通常包含对实现接口的引用。
- 扩展抽象（Refined Abstraction）：对抽象的扩展，可以是抽象类的子类或具体实现类。
- 实现（Implementor）：定义实现接口，提供基本操作的接口。
- 具体实现（Concrete Implementor）：实现实现接口的具体类。
#### Demo
桥接接口
```java
public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}
```
实现桥接接口
```java
public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: red, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}

public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: green, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}
```
使用 _DrawAPI_ 接口创建抽象类 _Shape_
```java
public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();  
}
```
创建实现了 _Shape_ 抽象类的实体类
```java
public class Circle extends Shape {
   private int x, y, radius;
 
   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }
 
   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
```
客户端
```java
public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());
 
      redCircle.draw();
      greenCircle.draw();
   }
}
```
结果：
```text
Drawing Circle[ color: red, radius: 10, x: 100, 100]
Drawing Circle[  color: green, radius: 10, x: 100, 100]
```





## 行为型模式

类和对象如何交互，及划分责任和算法。
### 模板模式

定义一个算法结构，而将一些步骤延迟到子类实现。
子类可以重新定义算法的某些步骤，而不用改变算法的结构。
#### UML
![](attachments/Pasted%20image%2020240517155303.png)
Demo
模板抽象类
```java
public abstract class CaffeineBeverage {
    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }
    abstract void brew();
    abstract void addCondiments();
    void boilWater() {
        System.out.println("boilWater");
    }
    void pourInCup() {
        System.out.println("pourInCup");
    }
}
```
实现类
```java
//咖啡实现类
public class Coffee extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("Coffee.brew");
    }
    @Override
    void addCondiments() {
        System.out.println("Coffee.addCondiments");
    }
}
//茶实现类
public class Tea extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("Tea.brew");
    }
    @Override
    void addCondiments() {
        System.out.println("Tea.addCondiments");
    }
}
```
客户端
```java
public class Client {
    public static void main(String[] args) {
        CaffeineBeverage caffeineBeverage = new Coffee();
        caffeineBeverage.prepareRecipe();
        System.out.println("-----------");
        caffeineBeverage = new Tea();
        caffeineBeverage.prepareRecipe();
    }
}
```
结果
```text
boilWater
Coffee.brew
pourInCup
Coffee.addCondiments
-----------
boilWater
Tea.brew
pourInCup
Tea.addCondiments
```
### 策略模式

定义一系列算法，把他们封装起来，并且使它们可以相互替换。
#### UML
![](attachments/Pasted%20image%2020240517154508.png)
#### Demo
抽象策略角色
```java
public interface QuackBehavior {
    void quack();
}
```
具体策略角色
```java
public class Quack implements QuackBehavior {
    @Override
    public void quack() {
        System.out.println("quack!");
    }
}

public class Squeak implements QuackBehavior{
    @Override
    public void quack() {
        System.out.println("squeak!");
    }
}
```
环境角色（Context）
```java
public class Duck {
    private QuackBehavior quackBehavior;
    public void performQuack() {
        if (quackBehavior != null) {
            quackBehavior.quack();
        }
    }
    public void setQuackBehavior(QuackBehavior quackBehavior) {
        this.quackBehavior = quackBehavior;
    }
}
```
客户端
```java
public class Client {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.setQuackBehavior(new Squeak());
        duck.performQuack();
        duck.setQuackBehavior(new Quack());
        duck.performQuack();
    }
}
```
结果
```text
squeak!
quack!
```
### 观察者模式
- 定义对象间的一种一对多的依赖关系；
- 当1个对象的状态发生改变时，所有依赖于它的对象都将得到通知 & 自动更新对应操作。
> 又称：发布 / 订阅模式
#### UML
![](attachments/Pasted%20image%2020240517162710.png)
#### **核心角色**
- 主题（Subject）：也称为被观察者或可观察者，它是具有状态的对象，并维护着一个观察者列表。主题提供了添加、删除和通知观察者的方法。
- 观察者（Observer）：观察者是接收主题通知的对象。观察者需要实现一个更新方法，当收到主题的通知时，调用该方法进行更新操作。
- 具体主题（Concrete Subject）：具体主题是主题的具体实现类。它维护着观察者列表，并在状态发生改变时通知观察者。
- 具体观察者（Concrete Observer）：具体观察者是观察者的具体实现类。它实现了更新方法，定义了在收到主题通知时需要执行的具体操作
#### Demo
```java
import java.util.ArrayList;
import java.util.List;
public class Subject {
   
   private List<Observer> observers 
      = new ArrayList<Observer>();
   private int state;
 
   public int getState() {
      return state;
   }
 
   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }
 
   public void attach(Observer observer){
      observers.add(observer);      
   }
 
   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }  
}
```

```java
public abstract class Observer {
   protected Subject subject;
   public abstract void update();
}
```

```java
//二进制
public class BinaryObserver extends Observer{
 
   public BinaryObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( "Binary String: " 
      + Integer.toBinaryString( subject.getState() ) ); 
   }
}
//八进制
public class OctalObserver extends Observer{
 
   public OctalObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
     System.out.println( "Octal String: " 
     + Integer.toOctalString( subject.getState() ) ); 
   }
}

//十六进制
public class HexaObserver extends Observer{
 
   public HexaObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( "Hex String: " 
      + Integer.toHexString( subject.getState() ).toUpperCase() ); 
   }
}

```
客户端
```java
public class ObserverPatternDemo {
   public static void main(String[] args) {
      Subject subject = new Subject();
       //放入主题
      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);
 
      System.out.println("First state change: 15");   
      subject.setState(15);//通知
      System.out.println("Second state change: 10");  
      subject.setState(10);
   }
}
```
结果
```text
First state change: 15
Hex String: F
Octal String: 17
Binary String: 1111
-------------------------
Second state change: 10
Hex String: A
Octal String: 12
Binary String: 1010

```

### 解释器模式

提供了评估语言的语法或表达式的方式，它属于行为型模式。
这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
#### UML
![](attachments/Pasted%20image%2020240517171308.png)
#### Demo

以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。
例如一颗解析树为 D And (A Or (B C))，文本 "D A" 满足该解析树定义的规则。
这里的 Context 指的是 String。

表达式抽象类
```java
public abstract class Expression {
    public abstract boolean interpret(String str);
}
```
表达式实现类
```java
public class TerminalExpression extends Expression {
    private String literal = null;
    public TerminalExpression(String str) {
        literal = str;
    }
    public boolean interpret(String str) {
        StringTokenizer st = new StringTokenizer(str);
        while (st.hasMoreTokens()) {
            String test = st.nextToken();
            if (test.equals(literal)) {
                return true;
            }
        }
        return false;
    }
}
```

```java
public class AndExpression extends Expression {
    private Expression expression1 = null;
    private Expression expression2 = null;
    public AndExpression(Expression expression1, Expression expression2) {
        this.expression1 = expression1;
        this.expression2 = expression2;
    }
    public boolean interpret(String str) {
        return expression1.interpret(str) && expression2.interpret(str);
    }
}
```

```java
public class OrExpression extends Expression {
    private Expression expression1 = null;
    private Expression expression2 = null;
	    public OrExpression(Expression expression1, Expression expression2) {
        this.expression1 = expression1;
        this.expression2 = expression2;
    }
    public boolean interpret(String str) {
        return expression1.interpret(str) || expression2.interpret(str);
    }
}
```
客户端
```java
public class Client {
    /**
     * 构建解析树
     */
    public static Expression buildInterpreterTree() {
        // Literal
        Expression terminal1 = new TerminalExpression("A");
        Expression terminal2 = new TerminalExpression("B");
        Expression terminal3 = new TerminalExpression("C");
        Expression terminal4 = new TerminalExpression("D");
        // B C
        Expression alternation1 = new OrExpression(terminal2, terminal3);
        // A Or (B C)
        Expression alternation2 = new OrExpression(terminal1, alternation1);
        // D And (A Or (B C))
        return new AndExpression(terminal4, alternation2);
    }
    public static void main(String[] args) {
        Expression define = buildInterpreterTree();
        String context1 = "D A";
        String context2 = "A B";
        System.out.println(define.interpret(context1));
        System.out.println(define.interpret(context2));
    }
}
```
结果
```text
true
false
```


### 状态模式

允许一个对象在其对象内部状态改变时改变它的行为。
#### UML
![](attachments/Pasted%20image%2020240517172644.png)
#### Demo
状态接口
```java
public interface State {
   public void doAction(Context context);
}
```
状态接口实现
```java
public class StartState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in start state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Start State";
   }
}


public class StopState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in stop state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Stop State";
   }
}
```
上下文
```java
public class Context {
   private State state;
 
   public Context(){
      state = null;
   }
 
   public void setState(State state){
      this.state = state;     
   }
 
   public State getState(){
      return state;
   }
}
```
客户端
```java
public class StatePatternDemo {
   public static void main(String[] args) {
      Context context = new Context();
 
      StartState startState = new StartState();
      startState.doAction(context);
 
      System.out.println(context.getState().toString());
 
      StopState stopState = new StopState();
      stopState.doAction(context);
 
      System.out.println(context.getState().toString());
   }
}
```
输出
```java
Player is in start state
Start State
Player is in stop state
Stop State
```

### 备忘录模式

在不破坏封装的前提下，保持对象的内部状态。
#### UML
![](attachments/Pasted%20image%2020240521213619.png)
#### Demo
Memento 类备忘录
```java
public class Memento {
   private String state;
 
   public Memento(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }  
}
```
Originator  原发器
```java
public class Originator {
   private String state;
 
   public void setState(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }
 
   public Memento saveStateToMemento(){
      return new Memento(state);
   }
 
   public void getStateFromMemento(Memento Memento){
      state = Memento.getState();
   }
}
```
 _CareTaker_  负责人
```java
public class CareTaker {
   private List<Memento> mementoList = new ArrayList<Memento>();
 
   public void add(Memento state){
      mementoList.add(state);
   }
 
   public Memento get(int index){
      return mementoList.get(index);
   }
}
```
客户端
```java
public class MementoPatternDemo {
   public static void main(String[] args) {
      Originator originator = new Originator();//原发器
      CareTaker careTaker = new CareTaker();//负责人
      originator.setState("State #1");
      originator.setState("State #2");
      careTaker.add(originator.saveStateToMemento());//负责人添加备忘
      originator.setState("State #3");
      careTaker.add(originator.saveStateToMemento());//负责人添加备忘
      originator.setState("State #4");
 
      System.out.println("Current State: " + originator.getState());    
      originator.getStateFromMemento(careTaker.get(0));//获取备忘
      System.out.println("First saved State: " + originator.getState());
      originator.getStateFromMemento(careTaker.get(1));//获取备忘
      System.out.println("Second saved State: " + originator.getState());
   }
}
```
结果
```java
Current State: State #4
First saved State: State #2
Second saved State: State #3
```
### 中介者模式
用一个中介对象来封装一系列的对象交互。
#### UML
![](attachments/Pasted%20image%2020240521222645.png)
Demo
创建中介类
```java
public class ChatRoom {
   public static void showMessage(User user, String message){
      System.out.println(new Date().toString()
         + " [" + user.getName() +"] : " + message);
   }
}
```
创建 user 类
```java
public class User {
   private String name;
 
   public String getName() {
      return name;
   }
 
   public void setName(String name) {
      this.name = name;
   }
 
   public User(String name){
      this.name  = name;
   }
 
   public void sendMessage(String message){
      ChatRoom.showMessage(this,message);
   }
}
```
使用 _User_ 对象来显示他们之间的通信
```java
public class MediatorPatternDemo {
   public static void main(String[] args) {
      User robert = new User("Robert");
      User john = new User("John");
 
      robert.sendMessage("Hi! John!");
      john.sendMessage("Hello! Robert!");
   }
}
```
结果
```java
Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!
Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!
```
### 命令模式
将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。
#### UML
![](attachments/Pasted%20image%2020240521224420.png)
#### 核心角色 
- **命令（Command）:**
    - 定义了执行操作的接口，通常包含一个 `execute` 方法，用于调用具体的操作。
- **具体命令（ConcreteCommand）:**
    - 实现了命令接口，负责执行具体的操作。它通常包含了对接收者的引用，通过调用接收者的方法来完成请求的处理。
- **接收者（Receiver）:**
    - 知道如何执行与请求相关的操作，实际执行命令的对象。
- **调用者/请求者（Invoker）:**
    - 发送命令的对象，它包含了一个命令对象并能触发命令的执行。调用者并不直接处理请求，而是通过将请求传递给命令对象来实现。
- **客户端（Client）:**
    - 创建具体命令对象并设置其接收者，将命令对象交给调用者执行。
#### Demo
命令（Command）
```java
public interface Command {
    void execute();
}
```
具体命令（ConcreteCommand）
```java
public class LightOnCommand implements Command {
    Light light;
    public LightOnCommand(Light light) {
        this.light = light;
    }
    @Override
    public void execute() {
        light.on();
    }
}

public class LightOffCommand implements Command {
    Light light;
    public LightOffCommand(Light light) {
        this.light = light;
    }
    @Override
    public void execute() {
        light.off();
    }
}
```
接收者（Receiver）
```java
public class Light {
    public void on() {
        System.out.println("Light is on!");
    }
    public void off() {
        System.out.println("Light is off!");
    }
}
```
调用者/请求者（Invoker）
```java
public class Invoker {
    private Command[] onCommands;
    private Command[] offCommands;
    private final int slotNum = 7;
    public Invoker() {
        this.onCommands = new Command[slotNum];
        this.offCommands = new Command[slotNum];
    }
    public void setOnCommand(Command command, int slot) {
        onCommands[slot] = command;
    }
    public void setOffCommand(Command command, int slot) {
        offCommands[slot] = command;
    }
    public void onButtonWasPushed(int slot) {
        onCommands[slot].execute();
    }
    public void offButtonWasPushed(int slot) {
        offCommands[slot].execute();
    }
}
```
客户端（Client）
```java
public class Client {
    public static void main(String[] args) {
        Invoker invoker = new Invoker();//调用者
        Light light = new Light();
        Command lightOnCommand = new LightOnCommand(light);
        Command lightOffCommand = new LightOffCommand(light);
        invoker.setOnCommand(lightOnCommand, 0);//设置开灯命令
        invoker.setOffCommand(lightOffCommand, 0);//设置关灯命令
        invoker.onButtonWasPushed(0);//使用开灯命令
        invoker.offButtonWasPushed(0);//使用关灯命令
    }
}
```
结果
```
Light is on!
Light is off!
```

### 访问者模式

在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
#### 核心角色

- Visitor: 访问者，为每一个 ConcreteElement 声明一个 visit 操作
- ConcreteVisitor: 具体访问者，存储遍历过程中的累计结果
- ObjectStructure: 对象结构，可以是组合结构，或者是一个集合。

#### UML
![](attachments/Pasted%20image%2020240522091137.png)
#### Demo
元素
```java
public interface Element {
    void accept(Visitor visitor);
}
```
对象结构，可以是组合结构，或者是一个集合
```java
class CustomerGroup {
    private List<Customer> customers = new ArrayList<>();
    void accept(Visitor visitor) {
        for (Customer customer : customers) {
            customer.accept(visitor);
        }
    }
    void addCustomer(Customer customer) {
        customers.add(customer);
    }
}
```
ConcreteElement 具体元素
```java
public class Customer implements Element {
    private String name;
    private List<Order> orders = new ArrayList<>();
    Customer(String name) {
        this.name = name;
    }
    String getName() {
        return name;
    }
    void addOrder(Order order) {
        orders.add(order);
    }
    public void accept(Visitor visitor) {
        visitor.visit(this);
        for (Order order : orders) {
            order.accept(visitor);
        }
    }
}
public class Order implements Element {
    private String name;
    private List<Item> items = new ArrayList();
    Order(String name) {
        this.name = name;
    }
    Order(String name, String itemName) {
        this.name = name;
        this.addItem(new Item(itemName));
    }
    String getName() {
        return name;
    }
    void addItem(Item item) {
        items.add(item);
    }
    public void accept(Visitor visitor) {
        visitor.visit(this);
        for (Item item : items) {
            item.accept(visitor);
        }
    }
}
public class Item implements Element {
    private String name;
    Item(String name) {
        this.name = name;
    }
    String getName() {
        return name;
    }
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
```
Visitor 访问者
```java
public interface Visitor {
    void visit(Customer customer);
    void visit(Order order);
    void visit(Item item);
}
```
具体访问者
```java
public class GeneralReport implements Visitor {
    private int customersNo;
    private int ordersNo;
    private int itemsNo;
    public void visit(Customer customer) {
        System.out.println(customer.getName());
        customersNo++;
    }
    public void visit(Order order) {
        System.out.println(order.getName());
        ordersNo++;
    }
    public void visit(Item item) {
        System.out.println(item.getName());
        itemsNo++;
    }
    public void displayResults() {
        System.out.println("Number of customers: " + customersNo);
        System.out.println("Number of orders:    " + ordersNo);
        System.out.println("Number of items:     " + itemsNo);
    }
}
```
客户端
```java
public class Client {
    public static void main(String[] args) {
        //元素具体实现  customer1(order1,order2,order3)
        Customer customer1 = new Customer("customer1");
        customer1.addOrder(new Order("order1", "item1"));
        customer1.addOrder(new Order("order2", "item1"));
        customer1.addOrder(new Order("order3", "item1"));
         //元素具体实现  order(item_a1,item_a2,item_a3)
        Order order = new Order("order_a");
        order.addItem(new Item("item_a1"));
        order.addItem(new Item("item_a2"));
        order.addItem(new Item("item_a3"));
        //元素具体实现  customer2(order)
        Customer customer2 = new Customer("customer2");
        customer2.addOrder(order);
        //集合
        CustomerGroup customers = new CustomerGroup();
        customers.addCustomer(customer1);
        customers.addCustomer(customer2);
        //访问者
        GeneralReport visitor = new GeneralReport();
        customers.accept(visitor);
        visitor.displayResults();
    }
}
```
结果
```
customer1
order1
item1
order2
item1
order3
item1
customer2
order_a
item_a1
item_a2
item_a3
Number of customers: 2
Number of orders:    4
Number of items:     6
```

### 责任链模式

将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。
#### UML
![](attachments/Pasted%20image%2020240522161940.png)
#### 核心角色
- **抽象处理者（Handler）:**
    - 定义一个处理请求的接口，通常包含一个处理请求的方法（如 `handleRequest`）和一个指向下一个处理者的引用（后继者）。
- **具体处理者（ConcreteHandler）:**
    - 实现了抽象处理者接口，负责处理请求。如果能够处理该请求，则直接处理；否则，将请求传递给下一个处理者。
- **客户端（Client）:**
    - 创建处理者对象，并将它们连接成一条责任链。通常，客户端只需要将请求发送给责任链的第一个处理者，无需关心请求的具体处理过程。
#### Demo
抽象处理者（Handler）
```java
public abstract class Handler {
    protected Handler successor;
    public Handler(Handler successor) {
        this.successor = successor;
    }
    protected abstract void handleRequest(Request request);
}
```
具体处理者（ConcreteHandler）
```java
public class ConcreteHandler1 extends Handler {
    public ConcreteHandler1(Handler successor) {
        super(successor);
    }
    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.type1) {
            System.out.println(request.getName() + " is handle by ConcreteHandler1");
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}


public class ConcreteHandler2 extends Handler{
    public ConcreteHandler2(Handler successor) {
        super(successor);
    }
    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.type2) {
            System.out.println(request.getName() + " is handle by ConcreteHandler2");
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
```
请求类
```java
public class Request {
    private RequestType type;
    private String name;
    public Request(RequestType type, String name) {
        this.type = type;
        this.name = name;
    }
    public RequestType getType() {
        return type;
    }
    public String getName() {
        return name;
    }
}
```
请求枚举
```java
public enum RequestType {
    type1, type2
}
```
客户端
```java
public class Client {
    public static void main(String[] args) {
        Handler handler1 = new ConcreteHandler1(null);//处理程序1
        Handler handler2 = new ConcreteHandler2(handler1);
        Request request1 = new Request(RequestType.type1, "request1");
        handler2.handleRequest(request1);
        Request request2 = new Request(RequestType.type2, "request2");
        handler2.handleRequest(request2);
    }
}
```
结果
```java
request1 is handle by ConcreteHandler1
request2 is handle by ConcreteHandler2
```

### 迭代器模式

一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
#### UML
![](attachments/Pasted%20image%2020240522171706.png)
#### Demo
迭代器接口
```java
public interface Iterator {
   public boolean hasNext();
   public Object next();
}
```
迭代器
```java
public interface Container {
   public Iterator getIterator();
}
```
名字仓库
```java
public class NameRepository implements Container {
   public String[] names = {"Robert" , "John" ,"Julie" , "Lora"};
 
   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }
 
   private class NameIterator implements Iterator {
 
      int index;
 
      @Override
      public boolean hasNext() {
         if(index < names.length){
            return true;
         }
         return false;
      }
 
      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }     
   }
}
```
客户端
```java
public class IteratorPatternDemo {
   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();
 
      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println("Name : " + name);
      }  
   }
}
```
结果
```java
Name : Robert
Name : John
Name : Julie
Name : Lora
```

## 参考

-   [简书——这是一份全面 & 详细的设计模式学习指南](https://www.jianshu.com/p/6e5eda3a51af)  

-  [设计模式知识体系详解](https://pdai.tech/md/dev-spec/pattern/1_overview.html)

-  [runoob——设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

-  [refactoringguru](https://refactoringguru.cn/design-patterns/composite)
